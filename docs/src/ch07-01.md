# 文件系统的功能需求

## POSIX 兼容与更快速便捷的 API

POSIX 定义了一套操作文件的系统接口，例如 `open(path, flag), close(fd), read(fd, buf, nbyte), write(fd, buf, nbyte), fsync(fd)` 等，包括 Linux 在内的诸多系统均采用了这些接口。
不同的编程语言通常会对这些接口二次封装，例如 C++ 中的 `std::fstream`, Python 的 `file` 对象，以及 Rust 的 `std::fs::File` 等。
它们能够与编程语言的资源管理、错误处理等机制和特性结合得更紧密，从而提供更良好的开发体验，例如依靠资源获取即初始化 (RAII) 或是垃圾回收 (GC) 等机制，在文件对象析构时自动调用 `close` 接口关闭文件，无需开发者手动关闭。

额外的封装和抽象常常以性能为代价，如 Rust 的标准库仍需调用 libc 的库函数，再调用 POSIX 的文件系统调用接口，相比 C 程序的调用路径更长。
而 unikernel 的架构提供了重新思考和设计这些系统接口的机遇。
内核与应用直接链接为一个完整的可执行程序，不需要通过二进制接口跨越特权级和地址空间的边界，而是可以直接调用内核函数。

在 ArceOS 中，我们采用与 Rust 标准库相同的文件 API, Rust 语言开发的应用调用时可以直接返回内核的文件对象。
这样不仅去掉了对 POSIX 接口额外的封装带来的开销，还可以利用 Rust 的众多高级语言特性，例如通过 RAII 避免资源泄漏、所有权机制在编译期检查并发冲突、`async/await` 的异步编程等。

为了兼容已有的 C 或其他语言编写的应用，ArceOS 也需要提供 POSIX API，并在具体实现上有所优化，但效果并不如 Rust 的显著。

## 文件系统与虚拟文件系统

ArceOS 需要为不同的文件系统提供统一的接口，而具体的文件系统只需包装实现这套接口即可接入 ArceOS 。
此外，按照 Unix/Linux “一切皆文件”的设计哲学，便于系统管理，ArceOS 还需要实现进程文件系统 procfs ，设备文件系统 devfs 等。

## 块设备驱动

从文件系统的角度，块设备通常是提供一段连续的编号，每个编号对应一个固定大小的数据块，对于驱动而言就至少需要提供查询块大小和块数量，读取、写入特定编号的块的功能。
这也是我们首次在 ArceOS 中引入设备驱动，因此除了具体的块设备之外，我们还需要一套驱动框架，对各类驱动进行抽象和封装。
