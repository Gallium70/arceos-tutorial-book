# 网络协议栈/网卡驱动的功能需求

## 选择网络协议栈

计算机网络协议种类繁多，作为 unikernel ，我们在满足应用需求的基础上，尽可能保持系统组件精简；另一方面，从组件化的角度出发，我们可以选择已有的较成熟的协议栈实现，减少重复开发工作。结合这两点，我们选择了 [smoltcp](https://github.com/smoltcp-rs/smoltcp) 作为网络协议栈。 smoltcp 支持以太网, ARP/ND, IPv4/IPv6, ICMP/ICMPv6, TCP, UDP 等协议，可满足大部分应用的网络需求，在嵌入式和实时系统中得到广泛应用。smoltcp 提供了所需的[网卡设备抽象接口](https://docs.rs/smoltcp/latest/smoltcp/phy/index.html)，我们在网卡驱动中实现该接口即可与协议栈整合。

## 网卡的运行模式

常见的网卡通过 MMIO 或 PCI 等总线提供一组配置寄存器，通过一个或多个环形队列传递用于接收和发送数据的缓冲区描述符（包含地址、长度、编号等信息），数据平面由 DMA 访问对应的缓冲区传递数据。这一 I/O 模式也不仅局限于网卡，在硬盘、显卡等设备上也很常见。

以 `virtio-net` 为例，下图是 `virtio-net` 的架构示意图：

![vn](assets/virtio-net.png)

我们的 unikernel 将运行在 Guest Kernel 的位置上。`descs` 中存储了若干缓冲区描述符，`avail` 和 `used` 是两个环形队列，分别用于内核向设备提交可用的描述符，以及设备将使用过的描述符返回给内核。

## 网卡驱动的功能

网卡驱动发送数据包的典型过程如下：

1. 驱动构造缓冲区和描述符，存入 `desc` 表中；
2. 驱动将对应的缓冲区描述符写入 `avail` 队列；
3. 驱动通知设备有缓冲区可用；
4. 设备根据 `avail` 队列找到对应的缓冲区描述符，再根据描述符从内存中读取数据并发送（在图中“设备”由宿主机用户态的 Qemu 进程模拟）；
5. 设备将发送完成的描述符写入 `used` 队列；
6. 设备通知驱动发送完成；
7. 驱动从 `used` 队列中回收缓冲区。

接收过程与上述基本相同，区别在于此时设备向缓冲区中写入收到的数据，而非从中读取。在这个过程中，网卡驱动需要维护缓冲区和队列的状态，并与协议栈交互。除此之外，还有些与具体网卡相关的初始化、配置等操作，这一部分需要根据网卡的硬件手册实现。
